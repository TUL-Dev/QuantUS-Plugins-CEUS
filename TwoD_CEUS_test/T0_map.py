import numpy as np

def generate_t0_map(pixel_data, seg_mask, threshold=150, start_frame=50, end_frame=250):
    """
    Generate T0 map showing when pixels first reach threshold intensity.

    The T0 map assigns higher values to pixels that light up earlier, creating a
    heatmap where brighter regions indicate earlier contrast arrival.

    Parameters
    ----------
    pixel_data : numpy.ndarray
        Image data with shape (n_frames, height, width)
    seg_mask : numpy.ndarray
        Binary segmentation mask with shape (height, width)
        Only pixels where seg_mask > 0 will be analyzed
    threshold : float, optional
        Intensity threshold for detecting contrast arrival (default: 150)
        Pixels must exceed this value to be considered "lit up"
    start_frame : int, optional
        First frame to analyze (default: 50)
    end_frame : int, optional
        Last frame to analyze (default: 250)

    Returns
    -------
    t0_map : numpy.ndarray
        Map with shape (height, width) where each pixel value represents
        the reverse time index when that pixel first exceeded the threshold.
        Higher values = earlier activation.
        Pixels that never exceeded threshold will have value 0.

    Examples
    --------
    >>> t0_map = generate_t0_map(image_data.pixel_data, seg_data.seg_mask,
    ...                          threshold=150, start_frame=50, end_frame=250)
    """
    n_frames, height, width = pixel_data.shape

    # Validate frame range
    if end_frame > n_frames:
        end_frame = n_frames
        print(f"Warning: end_frame adjusted to {n_frames} (max available)")

    # Initialize T0 map with zeros
    t0_map = np.zeros((height, width), dtype=np.float32)

    # Convert seg_mask to boolean for indexing
    roi_mask = seg_mask > 0

    # Loop through frames from start to end
    for i in range(start_frame, end_frame):
        # Get current frame
        current_frame = pixel_data[i, :, :]

        # Find pixels in ROI that exceed threshold AND haven't been assigned yet
        # (t0_map == 0 means pixel hasn't been detected yet)
        newly_detected = (current_frame >= threshold) & roi_mask & (t0_map == 0)

        # Assign reverse time index: earlier frames get higher values
        # This makes early activation appear brighter
        t0_map[newly_detected] = end_frame - i

    return t0_map

def get_t0_statistics(t0_map, seg_mask):
    """
    Calculate statistics from the T0 map within the ROI.

    Parameters
    ----------
    t0_map : numpy.ndarray
        T0 map generated by generate_t0_map()
    seg_mask : numpy.ndarray
        Segmentation mask defining the ROI

    Returns
    -------
    stats : dict
        Dictionary containing:
        - 'mean_t0': Mean T0 value in ROI (excluding zeros)
        - 'median_t0': Median T0 value in ROI (excluding zeros)
        - 'std_t0': Standard deviation of T0 values
        - 'min_t0': Minimum T0 value (excluding zeros)
        - 'max_t0': Maximum T0 value
        - 'coverage': Percentage of ROI pixels that were activated
    """
    roi_mask = seg_mask > 0
    t0_in_roi = t0_map[roi_mask]

    # Get non-zero values (activated pixels)
    activated = t0_in_roi[t0_in_roi > 0]

    stats = {
        'mean_t0': np.mean(activated) if len(activated) > 0 else 0,
        'median_t0': np.median(activated) if len(activated) > 0 else 0,
        'std_t0': np.std(activated) if len(activated) > 0 else 0,
        'min_t0': np.min(activated) if len(activated) > 0 else 0,
        'max_t0': np.max(activated) if len(activated) > 0 else 0,
        'coverage': (len(activated) / len(t0_in_roi) * 100) if len(t0_in_roi) > 0 else 0
    }

    return stats

def mask_t0_map(t0_map, seg_mask):
    """
    Create a masked version of T0 map showing only the ROI region.

    Pixels outside the ROI will be set to NaN for proper visualization.

    Parameters
    ----------
    t0_map : numpy.ndarray
        T0 map generated by generate_t0_map()
    seg_mask : numpy.ndarray
        Binary segmentation mask with shape (height, width)

    Returns
    -------
    masked_t0_map : numpy.ndarray
        T0 map with NaN values outside the ROI
    """
    masked_t0_map = t0_map.copy().astype(float)
    # Set pixels outside ROI to NaN (will appear transparent in matplotlib)
    masked_t0_map[seg_mask == 0] = np.nan
    return masked_t0_map
